<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OZO 「お象」: How to</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OZO 「お象」
   </div>
   <div id="projectbrief">Boost.Asio and libpq based asynchronous PostgreSQL unofficial header-only C++17 client library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_howto.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here are some examples of how to use OZO API.</p>
<ul>
<li><a href="#how-to">How to</a><ul>
<li><a href="#how-to-make-a-very-simple-request">How To Make A Very Simple Request</a></li>
<li><a href="#how-to-handle-error-properly">How To Handle Error Properly</a></li>
<li><a href="#how-to-map-column-names-to-column-numbers-at-compile-time">How To Map Column Names to Column Numbers At Compile Time</a></li>
<li><a href="#how-to-determine-which-type-do-i-need-to-use-for-the-postgresql-type">How To Determine Which Type Do I Need To Use For The PostgreSQL Type</a></li>
<li><a href="#how-to-bind-one-more-postgresql-type-for-c-type-with-existing-binding">How To Bind One More PostgreSQL Type For C++ Type With Existing Binding</a></li>
</ul>
</li>
</ul>
<h1>How To Make A Very Simple Request</h1>
<p>E.g. you have <em>very</em> simple table.</p>
<div class="fragment"><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users_info(</div>
<div class="line">    id          <span class="keywordtype">bigint</span>  <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    name        text,</div>
<div class="line">    amount      <span class="keywordtype">bigint</span>  <span class="keyword">NOT</span> <span class="stringliteral">NULL</span></div>
<div class="line">);</div>
</div><!-- fragment --><p>If you want to execute a query with no custom types or other advanced behavior then the simplest way to do this is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ozo/request.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ozo/connection_info.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ozo/shortcuts.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/asio.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// The boost io_context is the central management object for asyncronous operations.</span></div>
<div class="line">    boost::asio::io_context io;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Container of rows which accepts integer and nullable string columns in the sequence.</span></div>
<div class="line">    <span class="comment">// (This is an alias on std::vector of std::tuple - see the documentation)</span></div>
<div class="line">    <a class="code" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;</a>&gt; rows;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Connection info with host and port to connect to</span></div>
<div class="line">    <a class="code" href="classozo_1_1connection__info.html">ozo::connection_info</a> conn_info(<span class="stringliteral">&quot;host=... port=...&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// For _SQL literal</span></div>
<div class="line">    <span class="keyword">using namespace </span>ozo::literals;</div>
<div class="line">    <span class="comment">// Our query statement</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Request with connection provider, query and callback.</span></div>
<div class="line">    <a class="code" href="group__group-requests-functions.html#gac093ec8cf86103a3588072066767c418">ozo::request</a>(ozo::make_connector(conn_info, io), query, <a class="code" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a>(rows),</div>
<div class="line">            [&amp;](<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> conn) {</div>
<div class="line">        <span class="comment">// Here we got an error, so we can get:</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec) {</div>
<div class="line">            <span class="comment">// * Print error code&#39;s message</span></div>
<div class="line">            std::cerr &lt;&lt; ec.message();</div>
<div class="line">            <span class="comment">// * Print error message from underlying libpq</span></div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; <a class="code" href="group__group-connection-functions.html#gad1d7e52e998faef0eb5ea3767ca1ca70">ozo::error_message</a>(conn);</div>
<div class="line">            <span class="comment">// * Print additional error context from OZO</span></div>
<div class="line">            <span class="keywordflow">if</span> (!<a class="code" href="group__group-core-functions.html#ga602abbe1728381084559b85c3835b9bb">ozo::is_null_recursive</a>(conn)) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; <a class="code" href="group__group-connection-functions.html#ga27c523e2a2ef378b8a87681bdb58598b">ozo::get_error_context</a>(conn);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Connection should be in good state here,</span></div>
<div class="line">        <span class="comment">// typically you do not need to check it manually</span></div>
<div class="line">        assert(<a class="code" href="group__group-connection-functions.html#ga7d3c90effeb56a4e233fcfa959ce5e6e">ozo::connection_good</a>(conn));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We got results, let&#39;s do something with them, e.g. print them out</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;id&quot;</span> &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; <span class="stringliteral">&quot;name&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; row: res) {</div>
<div class="line">            std::cout &lt;&lt; std::get&lt;0&gt;(row) &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; std::get&lt;1&gt;(row) &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    io.run();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's look a little bit closer at this basic asynchronous query example.</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;</a>&gt; rows;</div>
</div><!-- fragment --><p>Here we define a result type. <code>ozo::rows_of</code> is an alias of <code>std::vector&lt;std::tuple&lt;...&gt;&gt;</code>. And <code>ozo::into</code> is an alias of <code>std::back_inserter</code>. So <code><a class="el" href="group__group-requests-functions.html#gac093ec8cf86103a3588072066767c418" title="Executes query and retrives a result from a database with time constraint.">ozo::request()</a></code> function will fill this vector of tuples by back inserting data from database's response, row by row. Please read the documentation for more details.</p>
<p>It is <em>very important</em> to preserve the same order of fields in the request and the types in the tuple (it is a little bit annoying, but there is a way to avoid it via <a href="https://www.boost.org/doc/libs/1_66_0/libs/hana/doc/html/index.html#tutorial-introspection-adapting">Boost.Hana</a> or <a href="https://www.boost.org/doc/libs/1_66_0/libs/fusion/doc/html/fusion/adapted.html">Boost.Fusion</a> structure adaptation).</p>
<p>Notice that the second position of the tuple is <code>std::optional&lt;std::string&gt;</code>.This is because the <code>name</code> field of the table can be <em>NULL</em>. Empty optional represents a <em>NULL</em> value (you can learn more about Nullable concept from the documentation). If if a <em>NULL</em> value is retrieved from the database for a type that is not an <code>std::optional</code>, then a deserialization error will occur.</p>
<p>Note that in the example, the table is defined with the first (id) and third (amount) columns as <em>NOT NULL</em>. This means that for queries retrieving those columns, it's not necessary to use <code>std::optional</code> for those fields. However, the second (name) column is <em>NULL</em>, and therefore must be an <code>std::optional</code> as explained in the paragraph above.</p>
<p>Note that it's acceptable to provide an <code>std::optional</code> for a <em>NOT NULL</em> field, but it is not acceptable to omit the <code>std::optional</code> for a field that is not <em>NOT NULL</em>, unless you can gaurentee the retrieved data will not be <em>NULL</em>. Failure to properly use <code>std::optional</code> will lead to a run-time error in case of a <em>NULL</em> value received from a database.</p>
<div class="fragment"><div class="line"><a class="code" href="classozo_1_1connection__info.html">ozo::connection_info</a> conn_info(<span class="stringliteral">&quot;host=... port=...&quot;</span>);</div>
</div><!-- fragment --><p>Now we need to create a connection information for database to connect to. This is our connection source which can create a connection for us as it will be needed (you can learn more about <a class="el" href="interface_connection_source.html" title="Connection source concept">ConnectionSource</a> and <a class="el" href="interface_connection_provider.html" title="Connection provider concept">ConnectionProvider</a> concepts from the documentation). It's also acceptable to provide a connection URI string, instead of the comma seperated version.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div>
</div><!-- fragment --><p>Here's our database query. The <code>_SQL</code> suffix is a user defined literal that converts the string that it is attached to into OZO's query data type. The parameter <code>std::int64_t(25)</code> is then added to the query accordingly. Note that the parameter will be passed as a separate binary parameter, but not as part of the query text.</p>
<p>Here is the asynchrounous function call <code><a class="el" href="group__group-requests-functions.html#gac093ec8cf86103a3588072066767c418" title="Executes query and retrives a result from a database with time constraint.">request()</a></code>.</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-requests-functions.html#gac093ec8cf86103a3588072066767c418">ozo::request</a>(ozo::make_connector(conn_info, io), query, <a class="code" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a>(res),</div>
<div class="line">        [&amp;](<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> conn) {</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">});</div>
</div><!-- fragment --><p><code>ozo::make_connector(conn_info, io)</code> - the first parameter is a <b><a class="el" href="interface_connection_provider.html" title="Connection provider concept">ConnectionProvider</a></b> or a <b><a class="el" href="interface_connection.html" title="Database connection concept.">Connection</a></b>. <b><a class="el" href="interface_connection_provider.html" title="Connection provider concept">ConnectionProvider</a></b> is an entity from which you can get a new (or already established) connection. <b><a class="el" href="interface_connection.html" title="Database connection concept.">Connection</a></b> is a <b><a class="el" href="interface_connection_provider.html" title="Connection provider concept">ConnectionProvider</a></b> since it can provide itself. So the query request will be performed within connection obtained for the first argument.</p>
<p><code>query</code> - the next argument is query which we discussed above.</p>
<p><code>ozo::into(res)</code> - the output parameter. In this case the out parameter is a back insert iterator to the result vector. Note, that the life time of the output parameter should be managed by a user. In this example it correctly placed on stack since its lifetime overlaps <code>io.run()</code> call. Another way you can do this is to use <code>std::make_shared</code>, and then store the resulting shared pointer in your callback function. That way the memory that <code>ozo::into</code> is writing into will stay valid until the callback function finishes.</p>
<p>The query output parameter can be an iterator with appropriate value type, or an <code>ozo::result</code> object which provides access to raw binary data. The second variant is not recommended since user would need to implement binary protocol parsing.</p>
<p><code>[&amp;](ozo::error_code ec, auto conn)</code> - completion function parameter, in this example it is a callback lambda. In other cases it can be <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/use_future.html">boost::asio::use_future</a>, <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/yield_context.html">boost::asio::yield_context</a> or any other compatible concept, such as: <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/async_result.html">boost::asio::async_result</a>, <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/async_completion.html">Completion Token</a>. The arguments of the call back are an error code <code>ec</code> (which is namely <code>boost::system::error_code</code> for now) and the connection <code>conn</code> with which the query was made.</p>
<p><code>for(auto&amp; row: res)</code> - This portion of the example executes if there is no error, and stands for the operations that you want your code to do when there is no error, such as printing out the contents of the output container.</p>
<hr  />
<h1>How To Handle Error Properly</h1>
<p>OZO uses <code>boost::system::error_code</code> to indicate an error and therefore, like <code>std::error_code</code>, it cannot provide any context-dependent information at all. So unfortunately <code>error_code::message()</code> returns only a static textual description of the code. But this is not enough, especially for sql errors. That's why the additional error information is needed and can be obtained via these two functions:</p>
<ul>
<li><code><a class="el" href="group__group-connection-functions.html#gad1d7e52e998faef0eb5ea3767ca1ca70" title="Get native libpq error message.">ozo::error_message()</a></code> - provides a <code>std::string_view</code> with native error message from libpq,</li>
<li><code><a class="el" href="group__group-connection-functions.html#ga27c523e2a2ef378b8a87681bdb58598b" title="Get additional error context.">ozo::get_error_context()</a></code> - provides an additional error context from OZO.</li>
</ul>
<p>Please learn more about these function in the documentation.</p>
<p><b>Example</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_error (std::ostream&amp; s, <a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec) {</div>
<div class="line">    s &lt;&lt; <span class="stringliteral">&quot;Request failed with error: &quot;</span> &lt;&lt; ec.message();</div>
<div class="line">    <span class="comment">// Here we should check if the connection is in null state to avoid UB.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__group-core-functions.html#ga602abbe1728381084559b85c3835b9bb">ozo::is_null_recursive</a>(connection)) {</div>
<div class="line">        <span class="comment">// Let&#39;s check libpq native error message and if so - print it out</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> msg = <a class="code" href="group__group-connection-functions.html#gad1d7e52e998faef0eb5ea3767ca1ca70">ozo::error_message</a>(connection); !msg.empty()) {</div>
<div class="line">            s &lt;&lt; <span class="stringliteral">&quot;, error message: &quot;</span> &lt;&lt; msg;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Sometimes libpq native error message is not enough, so let&#39;s check</span></div>
<div class="line">        <span class="comment">// the additional error context from OZO</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> ctx = <a class="code" href="group__group-connection-functions.html#ga27c523e2a2ef378b8a87681bdb58598b">ozo::get_error_context</a>(connection); !ctx.empty()) {</div>
<div class="line">            s &lt;&lt; <span class="stringliteral">&quot;, additional error context: &quot;</span> &lt;&lt; ctx;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1>How To Map Column Names to Column Numbers At Compile Time</h1>
<p>In in the first example we saw how to do a simple request, but in that example we needed to map data from the database to our container object strictly based on the column order: </p><div class="fragment"><div class="line"><a class="code" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;</a>&gt; rows;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div>
</div><!-- fragment --><p>If we interchange <code>id</code> and <code>name</code> in the query text we will get a run-time error. To be more robust to changes in the ordering of columns returned from the database, we can use Boost.Fusion to map column names to positions.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_row {</div>
<div class="line">    std::int64_t id;</div>
<div class="line">    std::optional&lt;std::string&gt; name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">BOOST_HANA_ADAPT_STRUCT(my_row, <span class="keywordtype">id</span>, name);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line">    std::vector&lt;my_row&gt; res;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-requests-functions.html#gac093ec8cf86103a3588072066767c418">ozo::request</a>(ozo::make_connector(io, conn_info), query, <a class="code" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a>(res),</div>
<div class="line">            [&amp;](<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> conn) {</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example, you can change the order of the fields in either <code>my_row</code> or your database query freely, as the fields are identified based on their name, and not based on their index in the tuple.</p>
<blockquote class="doxtable">
<p><b>Note:</b> you may use <code>BOOST_FUSION_ADAPT_STRUCT</code> and all of the <code>Boost.Fusion</code> adaptation mechanisms for structures, but it is recommended to use <code>Boost.Hana</code> for a faster and more modern approach. </p>
</blockquote>
<hr  />
<h1>How To Determine Which Type Do I Need To Use For The PostgreSQL Type</h1>
<p>It is a good question! Since we are using binary protocol and have serialization/deserialization system we also have a type system. It is easy and extandable. For build-in types you can look at <a href="../include/ozo/pg/types">ozo/pg/types</a> for difinitions like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ozo/pg/definitions.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group-type__system-mapping.html#ga208f8c018e90a843a873d56cc6acb943">OZO_PG_BIND_TYPE</a>(std::string, <span class="stringliteral">&quot;text&quot;</span>)</div>
</div><!-- fragment --><p><code><a class="el" href="group__group-type__system-mapping.html#ga208f8c018e90a843a873d56cc6acb943" title="Helper macro to define type mapping between C++ type and PostgreSQL type.">OZO_PG_BIND_TYPE(CPP_TYPE, PG_TYPE)</a></code> defines a C++ to built-in PostgreSQL type mapping. It's arguments are:</p>
<ul>
<li><code>CPP_TYPE</code> - C++ type.</li>
<li><code>PG_TYPE</code> - PostgreSQL type name.</li>
</ul>
<p>It defines C++ to built-in PostgreSQL type mapping with it's array. The current array represantation in OZO are std::vector, std::array, std::list, so for <code>std::string</code> type it could be <code>std::vector&lt;std::string&gt;</code>, <code>std::array&lt;std::string, N&gt;</code>, <code>std::list&lt;std::string&gt;</code>.</p>
<p>Since the mapping is many <b>C++</b> types to one <b>PostgreSQL</b> type, you can always map another C++ type as PostgreSQL type.</p>
<p>E.g. we have an in-library <code>text</code> type definition like:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-type__system-mapping.html#ga208f8c018e90a843a873d56cc6acb943">OZO_PG_BIND_TYPE</a>(std::string, <span class="stringliteral">&quot;text&quot;</span>)</div>
</div><!-- fragment --><p>You have your own brilliant string representation <code>Stroka</code> compatible with <code>const char* data(const Stroka&amp;)</code> and <code>const char* size(const Stroka&amp;)</code> functions (it is needed to use default introspection mechanisms). It can be included in type system and used as <code>text</code> representation like this:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-type__system-mapping.html#ga208f8c018e90a843a873d56cc6acb943">OZO_PG_BIND_TYPE</a>(Stroka, <span class="stringliteral">&quot;text&quot;</span>)</div>
</div><!-- fragment --><p>Now you can get <code>text</code> into <code>Stroka</code> type, and put <code>Stroka</code> object like text in queries.</p>
<hr  />
<h1>How To Bind One More PostgreSQL Type For C++ Type With Existing Binding</h1>
<p>This is very common problem. A lot of PostgreSQL types can be represented via the same C++ types. E.g. <code>text</code>, <code>name</code>, <code>varchar</code> can be easily and convenient represented via <code>std::string</code>. But it can not be done, due to relation "one to many" between PostgreSQL type and C++ types. You can map <code>text</code> to several C++ types but you can not map several PostgreSQL types to a single C++ type. There is a solution for the problem in the library - <code>OZO_STRONG_TYPEDEF</code>. This macro allows you to define an alias on a type with strong type definition guarantee.</p>
<p>E.g. alias and definition for <code>bytea</code> type may looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-core-types.html#ga61078d1ef7bd8132469c8f5b627376b2">OZO_STRONG_TYPEDEF</a>(std::string, bytea)</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code" href="group__group-type__system-mapping.html#ga208f8c018e90a843a873d56cc6acb943">OZO_PG_BIND_TYPE</a>(bytea, <span class="stringliteral">&quot;bytea&quot;</span>)</div>
</div><!-- fragment --><p>You can access for the underlying type via conversion operator or <code>get()</code> method:</p>
<div class="fragment"><div class="line">bytea wrapped_value;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> n = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>std::string&amp;<span class="keyword">&gt;</span>(wrapped_value).find(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keyword">auto</span> n = wrapped_value.get().find(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keywordtype">bool</span> is_good_string(<span class="keyword">const</span> std::string&amp; v);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keywordtype">bool</span> flag = is_good_string(wrapped_value);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__group-requests-functions_html_gac093ec8cf86103a3588072066767c418"><div class="ttname"><a href="group__group-requests-functions.html#gac093ec8cf86103a3588072066767c418">ozo::request</a></div><div class="ttdeci">decltype(auto) request(ConnectionProvider &amp;&amp;provider, BinaryQueryConvertible &amp;&amp;query, TimeConstraint time_constraint, Out out, CompletionToken &amp;&amp;token)</div><div class="ttdoc">Executes query and retrives a result from a database with time constraint.</div></div>
<div class="ttc" id="agroup__group-errors_html_ga8757df037905ea8c9b69073e350dd731"><div class="ttname"><a href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a></div><div class="ttdeci">boost::system::error_code error_code</div><div class="ttdoc">Error code representation of the library.</div><div class="ttdef"><b>Definition:</b> error.h:38</div></div>
<div class="ttc" id="agroup__group-connection-functions_html_gad1d7e52e998faef0eb5ea3767ca1ca70"><div class="ttname"><a href="group__group-connection-functions.html#gad1d7e52e998faef0eb5ea3767ca1ca70">ozo::error_message</a></div><div class="ttdeci">std::string_view error_message(const Connection &amp;conn)</div><div class="ttdoc">Get native libpq error message.</div><div class="ttdef"><b>Definition:</b> connection.h:97</div></div>
<div class="ttc" id="agroup__group-requests-types_html_gade9a42efa5064524382c2673de242f39"><div class="ttname"><a href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of</a></div><div class="ttdeci">std::vector&lt; typed_row&lt; Ts... &gt; &gt; rows_of</div><div class="ttdoc">Shortcut for easy result container definition.</div><div class="ttdef"><b>Definition:</b> shortcuts.h:37</div></div>
<div class="ttc" id="agroup__group-requests-functions_html_ga3e8f5ef58a370e79b7e554cd09fbc705"><div class="ttname"><a href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a></div><div class="ttdeci">constexpr auto into(T &amp;v)</div><div class="ttdoc">Shortcut for create result container back inserter.</div><div class="ttdef"><b>Definition:</b> shortcuts.h:85</div></div>
<div class="ttc" id="agroup__group-type__system-mapping_html_ga208f8c018e90a843a873d56cc6acb943"><div class="ttname"><a href="group__group-type__system-mapping.html#ga208f8c018e90a843a873d56cc6acb943">OZO_PG_BIND_TYPE</a></div><div class="ttdeci">#define OZO_PG_BIND_TYPE(CppType, PgTypeName)</div><div class="ttdoc">Helper macro to define type mapping between C++ type and PostgreSQL type.</div><div class="ttdef"><b>Definition:</b> definitions.h:140</div></div>
<div class="ttc" id="agroup__group-core-functions_html_ga602abbe1728381084559b85c3835b9bb"><div class="ttname"><a href="group__group-core-functions.html#ga602abbe1728381084559b85c3835b9bb">ozo::is_null_recursive</a></div><div class="ttdeci">constexpr bool is_null_recursive(T &amp;&amp;v) noexcept</div><div class="ttdoc">Indicates if one of unwrapped values is in null state.</div><div class="ttdef"><b>Definition:</b> recursive.h:78</div></div>
<div class="ttc" id="aclassozo_1_1connection__info_html"><div class="ttname"><a href="classozo_1_1connection__info.html">ozo::connection_info</a></div><div class="ttdoc">Connection source to a single host.</div><div class="ttdef"><b>Definition:</b> connection_info.h:28</div></div>
<div class="ttc" id="agroup__group-core-types_html_ga61078d1ef7bd8132469c8f5b627376b2"><div class="ttname"><a href="group__group-core-types.html#ga61078d1ef7bd8132469c8f5b627376b2">OZO_STRONG_TYPEDEF</a></div><div class="ttdeci">#define OZO_STRONG_TYPEDEF(base, type)</div><div class="ttdoc">Strong typedef.</div><div class="ttdef"><b>Definition:</b> strong_typedef.h:98</div></div>
<div class="ttc" id="agroup__group-connection-functions_html_ga7d3c90effeb56a4e233fcfa959ce5e6e"><div class="ttname"><a href="group__group-connection-functions.html#ga7d3c90effeb56a4e233fcfa959ce5e6e">ozo::connection_good</a></div><div class="ttdeci">bool connection_good(const Connection &amp;conn) noexcept</div><div class="ttdoc">Indicates if connection state is not bad.</div><div class="ttdef"><b>Definition:</b> connection.h:391</div></div>
<div class="ttc" id="agroup__group-connection-functions_html_ga27c523e2a2ef378b8a87681bdb58598b"><div class="ttname"><a href="group__group-connection-functions.html#ga27c523e2a2ef378b8a87681bdb58598b">ozo::get_error_context</a></div><div class="ttdeci">const auto &amp; get_error_context(const Connection &amp;conn)</div><div class="ttdoc">Get additional error context.</div><div class="ttdef"><b>Definition:</b> connection.h:124</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
